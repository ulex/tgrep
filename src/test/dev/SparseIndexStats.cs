using System.Collections.Concurrent;

namespace test.dev;

public class SparseIndexStats
{
  private const string StatsPath = "c:\\bench\\digraph_stats.csv";

  [Test]
  public async Task StatsDigram()
  {
    var result = new ConcurrentDictionary<(int, int), int>();

    var repo = new TestTrigramBuilderVisitor("c:\\bench\\testwt");
    await repo.AcceptAllFiles((s, l, arg3) =>
    {
      var bigrams = ReadBigrams(s);
      foreach (var bigram in bigrams)
      {
        result.AddOrUpdate(bigram.Key, static (_, arg) => arg, static (_, val, addVal) => val + addVal, bigram.Value);
      }
    });

    using var w = new StreamWriter(StatsPath);
    foreach (var i in result)
    {
      /*
      var r1 = new Rune(i.Key.Item1);
      var r2 = new Rune(i.Key.Item2);
      var digram = (r1.ToString() + r2.ToString());
      */
      w.WriteLine($"{i.Key.Item1}, {i.Key.Item2}, {i.Value}");
    }
  }

  public Dictionary<(int, int), int> ReadBigrams(string path)
  {
    var m = new Dictionary<(int, int), int>();
    const int fileBufSize = 4096;
    const int bufSize = +4;
    var fileStream = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read, fileBufSize);
    var reader = new StreamReader(fileStream);
    var fileContent = reader.ReadToEnd();// todo: traffic/memory usage

    int prev = 0;
    foreach (var rune in fileContent.EnumerateRunes())
    {
      var runeValue = rune.Value;
      if (runeValue == 0)
      {
        m.Clear();
        return m;
      }

      var key = (prev, runeValue);
      if (m.TryAdd(key, 1))
      {
        if (prev == 0) // optimize hotpath
          m.Clear();
      }
      else
      {
        m[key]++;
      }

      prev = runeValue;
    }

    return m;
  }

  [Test]
  public void WriteTable()
  {
    var data = ReadFromCsv(StatsPath);
    var array = new int[128 * 128];
    Array.Fill(array, 128);
    bool isAsciiLetter(int cp) => cp < char.MaxValue && char.IsAsciiLetter((char)cp);
    var letters = data.Where(kvp => isAsciiLetter(kvp.Key.Item1) && isAsciiLetter(kvp.Key.Item2)).ToList();
    var values = letters.Select(kvp => kvp.Value).Order().ToList();
    var histogram = new Histogram(values, 125);
    foreach (var kvp in letters)
    {
      array[kvp.Key.Item1 * 128 + kvp.Key.Item2] = histogram.GetBinNumber(kvp.Value);
    }

    Console.WriteLine("static byte[] al = new byte[] {");
    for (int i = 0; i < 128; i++)
    {
      for (int j = 0; j < 128; j++)
      {
        Console.Write($"{array[i * 128 + j],3},"); 
      }
      Console.WriteLine("");
    }

    Console.WriteLine("};");
  }

  public Dictionary<(int, int), int> ReadFromCsv(string path)
  {
    var m = new Dictionary<(int, int), int>();
    var reader = new StreamReader(path);
    string line;
    while ((line = reader.ReadLine()!) != null)
    {
      var s = line.Split(",");
      m.Add((int.Parse(s[0]), int.Parse(s[1])), int.Parse(s[2]));
    }

    return m;
  }


  // generated by llm
  public class Histogram
  {
    private List<int> data;
    private int numBins;
    private List<Tuple<int, int>> binIntervals;

    public Histogram(List<int> data, int numBins)
    {
      this.data = data;
      this.numBins = numBins;
      CalculateBinIntervals();
    }

    private void CalculateBinIntervals()
    {
      if (data.Count == 0)
      {
        binIntervals = new List<Tuple<int, int>>();
        return;
      }

      int minValue = data.Min();
      int maxValue = data.Max();

      double binWidth = (maxValue - minValue) / (double)numBins;

      binIntervals = new List<Tuple<int, int>>();
      int currentBinStart = minValue;

      for (int i = 0; i < numBins; i++)
      {
        int currentBinEnd = (i == numBins - 1) ? maxValue : (int)Math.Ceiling(currentBinStart + binWidth);
        binIntervals.Add(Tuple.Create(currentBinStart, currentBinEnd));
        currentBinStart = currentBinEnd + 1;
      }
    }

    public int GetBinNumber(int value)
    {
      for (int i = 0; i < binIntervals.Count; i++)
      {
        if (value >= binIntervals[i].Item1 && value <= binIntervals[i].Item2)
        {
          return i;
        }
      }

      // Value is outside the bin intervals
      return -1;
    }
  }
}